##  lock 


### 락을 사용하는 이유 
동시에 여러개의 트랜잭션이 수행될 때, 트랜잭션들이 DB의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어한다.

### 비관적락(Pessimistic lock)  
트랜잭션이 시작될때 충돌할거라고 비관적으로 보고 락을 건다. 중요한 데이터에 동시성 문제가 발생하지 못하도록 사용
A가 해당 테이블 row 읽을으면 lock 걸림 -> A 트랜잭션 커밋되면 락해제 후 다음 유저 접근 가능
<br>
<br>
단점: 로우 자체에 락을 걸어서 데드락이 일어날 가능성이 높음
<br>
<br>
데드락:두개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있는것, 한정된 자원을 여러 곳에서 사용하려고 할 때 발생
프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 '교착 상태
그래서 가장 현실적인 방법은 교착 상태 검출하는 방법


### 낙관적 락(Optimistic lock)
데이터 갱신 시 충돌이 발생하지 않을 것으로 가정하여 락을 걸지 않는 방식 -> 락이 아닌 버전 관리 기능을 통해서 트랜잭션 격리성 관리
Version 컬럼을 별도로 추가해서 충돌 방지 -> Version 정보를 사용하면 최초 커밋만 인정된다.

벌크 연산은 버전을 무시하기 때문에 벌크 연산에서는 버전을 증가시키려면 버전 필드를 강제로 증가시켜야 한다.

DB 가 제공하는 락 기능을 사용하지 않고 JPA 가 제공하는 버전 관리 기능을 사용 -> 애플리케이션에서 제공하는 락
커밋 전까지는 충돌을 알 수 없다.

충돌이 나면 롤백 처리는 개발자의 몫이다.
둘의 사용을 판단하는 기준을 읽기와 수정 비율이 어디에 가까운지 보고 판단해야 한다. 수정의 비율이 높다면 Pessimistic을 사용하고 읽기의 비중이 높다면 Optimistic을 사용한다.

### 낙관적 락보다 DB 트랜잭션 레벨을 Repeatable Read로 하면 되지 않을까?

Repeatable read는 선행 트랜잭션이 종료시까지 다른 트랜잭션이 update, delete하지 못하도록 완전히 락을 걸어버린다.
반면에 낙관적인 락은 애플리케이션 단에서 락을 걸지 않아 트랜잭션 자체를 blocking하지 않으면서도 다른 트랜잭션이 수정하는 것을 막아준다.

락을 거는 것 자체가 성능에 영향을 줄 수 있기 때문에 읽기 작업의 비율이 높은 경우 격리 레벨을 조정하는 것보다 낙관적인 락을 사용하는게 더 좋다.
